<!DOCTYPE html>
<!--
    GOAL: Interactive demonstration of browser pointing/touch input event APIs

    This program visualizes and logs mouse, touch, pointer, click, and gesture events to demonstrate:
    - How different event types fire 
    - The differences between event bubbling behavior (over/out vs enter/leave)
    - The redundancy between legacy (mouse/touch) and modern (pointer) event APIs
    - Browser-specific gesture detection methods (Safari native only)
    - Deprecated event types that should be avoided in modern development
    - shows errors instead of writing to the console

    Users can toggle each event type on/off.

    DECLINED PROPOSALS (intentionally not implemented for this demo):
    - Accessibility
    - Modal focus trapping and Escape-to-close behavior
    - Canvas HiDPI devicePixelRatio scaling
    - Defaulting one event family off (e.g., touch off with pointer on) 
    - Event log performance tweaks (batching, throttling, max line cap) and font size change
    - Debounced window resize handler
    - Wrapping setup in DOMContentLoaded
    - Feature detection gates for Safari-only gesture events before adding listeners

    KNOWN LIMITATIONS:
    - Browser DevTools touch emulation does not trigger OS-level touch behavior, so the 
      on-screen keyboard will not appear when tapping input fields in device mode. Test 
      on actual touch devices to verify keyboard interaction.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouse vs Touch Events</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font: Arial, sans-serif; background: #000; color: #fff; overflow: hidden; }
        #canvas { position: fixed; inset: 0; touch-action: none; }
        
        #info, #eventLog {
            position: fixed;
            top: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
        }
        #info { right: 10px; font-size: 12px; max-width: 300px; }
        #info p { margin-top: 10px; font-size: 11px; }
        #info button { margin-top: 10px; padding: 5px 10px; cursor: pointer; }
        
        #eventLog {
            left: 10px;
            font: 8px 'Courier New', monospace;
            color: lime;
            width: 700px;
            height: 400px;
            overflow-y: auto;
        }
        #eventLog::-webkit-scrollbar { width: 8px; }
        #eventLog::-webkit-scrollbar-track { background: rgba(255, 255, 255, 0.1); border-radius: 4px; }
        #eventLog::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.3); border-radius: 4px; }

        .redundant { color: orange !important; font-style: italic; }
        .deprecated { color: #c00 !important; text-decoration: line-through; }
        .error { color: red !important; font-weight: bold; }
        
        .event-type {
            margin: 5px 0;
            padding: 3px 8px;
            border-radius: 3px;
            display: inline-block;
            cursor: pointer;
            -webkit-user-select: none;
            user-select: none;
            transition: opacity 0.2s;
        }
        .event-type:hover { opacity: 0.8; }
        .event-type.disabled { text-decoration: line-through; opacity: 0.5; }
        .mouse { background: red; color: #fff; }
        .touch { background: lime; color: #000; }
        .pointer { background: blue; color: #fff; }
        .click { background: magenta; color: #fff; }
        .gesture { background: yellow; color: #000; }

        #guideModal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        #guideModal.show { display: flex; }

        #guideContent {
            background: #000;
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 30px;
            max-width: 700px;
            max-height: 80vh;
            overflow-y: auto;
            font: 14px/1.6 'Courier New', monospace;
            color: lime;
        }
        #guideContent h2 { color: #fff; margin: 0 0 20px; }
        #guideContent .section { margin-bottom: 20px; }
        #guideContent .section-title { color: yellow; font-weight: bold; margin-bottom: 10px; }
        #guideContent .redundant-example { color: orange; }
        #guideContent .deprecated-example { color: #c00; text-decoration: line-through; }
        #guideContent .subsection-spacing { margin-top: 10px; }

        #closeGuide {
            display: block;
            margin: 20px auto 0;
            padding: 10px 20px;
            background: #fff;
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        #closeGuide:hover { background: lime; }

        #keyboardInputContainer {
            margin-top: 15px;
        }
        #keyboardInputContainer label {
            display: block;
            margin-bottom: 5px;
        }
        #keyboardInput {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="info">
        <h3>Event Detection Methods (click to toggle):</h3>
        <div class="event-type mouse" data-event-type="mouse">Mouse Events</div>
        <div class="event-type touch" data-event-type="touch">Touch Events</div>
        <div class="event-type pointer" data-event-type="pointer">Pointer Events</div>
        <div class="event-type click" data-event-type="click">Click Events</div>
        <div class="event-type gesture" data-event-type="gesture">Gesture Events</div>
        <p>
            Click/tap anywhere to draw circles. Click event labels to enable/disable types.
        </p>
        <button type="button" id="clearCanvasBtn">Clear Canvas</button>
        <button type="button" id="clearLogBtn">Clear Log</button>
        <button type="button" id="showGuideBtn">Redundancy Guide</button>
        <div id="keyboardInputContainer">
            <label for="keyboardInput">Test Keyboard:</label>
            <input type="text" id="keyboardInput" placeholder="Tap to show keyboard">
        </div>
        <div>Version 10:58 AM 10/31/2024</div>
    </div>

    <pre id="eventLog"></pre>

    <div id="guideModal" role="dialog" aria-modal="true" aria-labelledby="guideTitle">
        <div id="guideContent">
            <h2 id="guideTitle">Event Redundancy Guide</h2>

            <div class="section">
                <div class="section-title">Color Legend:</div>
                <div><span class="redundant-example">ORANGE = Redundant events</span> - These fire alongside their modern equivalents</div>
                <div><span class="deprecated-example">RED = Deprecated events</span> - Should not be used</div>
            </div>

            <div class="section">
                <div class="section-title">1. POINTER events are MODERN (Use these!)</div>
                <div>• Pointer API unifies mouse + touch + pen into one API</div>
                <div>• On desktop with mouse: pointerdown fires WITH mousedown</div>
                <div>• On mobile with touch: pointerdown fires WITH touchstart</div>
                <div>• <strong>Recommendation:</strong> Use POINTER events for new projects</div>
            </div>

            <div class="section">
                <div class="section-title">2. MOUSE & TOUCH events are LEGACY</div>
                <div>• <span class="redundant-example">Mouse events</span>: mousedown/mouseup/mousemove (desktop only)</div>
                <div>• <span class="redundant-example">Touch events</span>: touchstart/touchend/touchmove (mobile only)</div>
                <div>• Both fire alongside pointer events on their respective platforms</div>
                <div>• Kept for backwards compatibility only</div>
            </div>

            <div class="section">
                <div class="section-title">3. CLICK events are COMPOSITE</div>
                <div>• Click events fire AFTER a complete down+up sequence</div>
                <div>• Typical sequence: pointerdown → pointerup → click</div>
                <div>• Or: mousedown → mouseup → click</div>
                <div>• Or: touchstart → touchend → click</div>
                <div>• <span class="redundant-example">All clicks are redundant</span> with their down/up events</div>
            </div>

            <div class="section">
                <div class="section-title">4. ENTER/LEAVE vs OVER/OUT</div>
                <div>• Same trigger, different bubbling behavior:</div>
                <div>• mouseenter/leave = no bubbling, fire once on element</div>
                <div>• mouseover/out = bubble through children, fire multiple times</div>
                <div>• Same distinction for pointerenter/leave vs pointerover/out</div>
            </div>

            <div class="section">
                <div class="section-title">5. GESTURE detection</div>
                <div>• Native gesturestart/change/end (Safari/iOS only, non-standard)</div>
                <div>• Browser-provided gesture events (not available in all browsers)</div>
            </div>

            <div class="section">
                <div class="section-title">6. DEPRECATED events (NOT used in this demo)</div>
                <div><strong>Mouse wheel events:</strong></div>
                <div>• <span class="deprecated-example">mousewheel</span> - Old WebKit/Blink, use "wheel" instead</div>
                <div>• <span class="deprecated-example">DOMMouseScroll</span> - Old Firefox, use "wheel" instead</div>
                <div>• <span class="deprecated-example">MozMousePixelScroll</span> - Old Firefox, use "wheel" instead</div>
                <div>• This demo uses modern "wheel" event only</div>
                <div class="subsection-spacing"><strong>IE10-11 specific events:</strong></div>
                <div>• <span class="deprecated-example">MSPointerEvent</span> family - IE's old pointer events</div>
                <div>  (MSPointerDown, MSPointerMove, MSPointerUp, etc.)</div>
                <div>• <span class="deprecated-example">MSGestureEvent</span> family - IE's gesture events</div>
                <div>  (MSGestureStart, MSGestureChange, MSGestureEnd, etc.)</div>
                <div>• Replaced by standard PointerEvent API in modern browsers</div>
            </div>

            <button type="button" id="closeGuide">Close</button>
        </div>
    </div>

    <script>
        let canvas, ctx, eventLog;

        function displayError(message) {
            const el = document.getElementById('eventLog');
            if (el) {
                const span = document.createElement('span');
                span.className = 'error';
                span.textContent = `[${new Date().toLocaleTimeString()}] ${message}\n`;
                el.appendChild(span);
                el.scrollTop = el.scrollHeight;
            } else {
                console.error(message);
            }
        }

        window.addEventListener('error', (e) => displayError(`Error: ${e.message}`));
        window.addEventListener('unhandledrejection', (e) => displayError(`Promise rejected: ${e.reason}`));

        canvas = document.getElementById('canvas');
        if (!canvas) throw new Error('Canvas element not found');
        ctx = canvas.getContext('2d');
        if (!ctx) throw new Error('Failed to get 2D context');
        eventLog = document.getElementById('eventLog');
        if (!eventLog) throw new Error('Event log element not found');

        const eventTypeEnabled = {
            mouse: false,
            touch: true,
            pointer: true,
            click: true,
            gesture: true
        };

        document.querySelectorAll('.event-type').forEach(label => {
            const eventType = label.getAttribute('data-event-type');
            if (eventType && !eventTypeEnabled[eventType]) {
                label.classList.add('disabled');
            }
            label.addEventListener('click', () => {
                if (eventType) {
                    eventTypeEnabled[eventType] = !eventTypeEnabled[eventType];
                    label.classList.toggle('disabled', !eventTypeEnabled[eventType]);
                    logEvent(`Event type "${eventType}" ${eventTypeEnabled[eventType] ? 'ENABLED' : 'DISABLED'}`);
                }
            });
        });

        function isEventTypeEnabled(eventType) {
            return eventTypeEnabled[eventType];
        }

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        const colors = {
            mouse: 'red',
            touch: 'lime',
            pointer: 'blue',
            click: 'magenta',
            gesture: 'yellow'
        };

        // Type determines size (all shapes are circles)
        const TYPE_SIZES = {
            DOWN: 25,
            UP: 20,
            MOVE: 15,
            WHEEL: 18,
            CLICK: 20,
            AUX_CLICK: 22,
            DOUBLE_CLICK: 35,
            CONTEXT_MENU: 40,
            GESTURE: 45
        };

        const DRAWING_CONSTANTS = {
            CIRCLE_ALPHA: 0.4,
            FULL_ALPHA: 1.0,
            FULL_CIRCLE_RADIANS: Math.PI * 2
        };
        
        const OFFSET = 5;
        const OFFSET_BY_TYPE = {
            mouse: { x: -OFFSET, y: -OFFSET },
            touch: { x: OFFSET, y: OFFSET },
            pointer: { x: 0, y: 0 },
            click: { x: -OFFSET, y: 0 },
            gesture: { x: 0, y: -OFFSET }
        };
        
        const formatCoords = (x, y) => `(${x.toFixed(1)}, ${y.toFixed(1)})`;
        
        function logEvent(message, type = 'normal') {
            const timestamp = new Date().toLocaleTimeString();
            const span = document.createElement('span');
            const typeClasses = {
                redundant: () => { span.className = 'redundant'; return message + ' [REDUNDANT]'; },
                deprecated: () => { span.className = 'deprecated'; return message + ' [DEPRECATED]'; },
                error: () => { span.className = 'error'; return message; }
            };
            span.textContent = `[${timestamp}] ${typeClasses[type]?.() || message}\n`;
            eventLog.appendChild(span);
            eventLog.scrollTop = eventLog.scrollHeight;
        }
        
        function drawCircle(x, y, color, size = 30, eventType = 'pointer') {
            const offset = OFFSET_BY_TYPE[eventType] || { x: 0, y: 0 };
            ctx.fillStyle = color;
            ctx.globalAlpha = DRAWING_CONSTANTS.CIRCLE_ALPHA;
            ctx.beginPath();
            ctx.arc(x + offset.x, y + offset.y, size, 0, DRAWING_CONSTANTS.FULL_CIRCLE_RADIANS);
            ctx.fill();
            ctx.globalAlpha = DRAWING_CONSTANTS.FULL_ALPHA;
        }
        
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        function clearLog() {
            eventLog.textContent = '';
        }

        document.getElementById('clearCanvasBtn').addEventListener('click', clearCanvas);
        document.getElementById('clearLogBtn').addEventListener('click', clearLog);
        
        function registerEvent(eventType, eventName, handler, options = {}) {
            canvas.addEventListener(eventName, (e) => {
                if (!isEventTypeEnabled(eventType)) return;
                handler(e);
            }, options);
        }
        
        function createLogHandler(logMessage, isRedundant = false) {
            return (e) => {
                logEvent(logMessage(e), isRedundant ? 'redundant' : 'normal');
            };
        }

        const guideModal = document.getElementById('guideModal');
        const showGuideBtn = document.getElementById('showGuideBtn');
        const closeGuideBtn = document.getElementById('closeGuide');
        let previouslyFocusedElement = null;

        const openModal = () => {
            previouslyFocusedElement = document.activeElement;
            guideModal.classList.add('show');
            closeGuideBtn.focus();
        };

        const closeModal = () => {
            guideModal.classList.remove('show');
            previouslyFocusedElement?.focus();
        };

        showGuideBtn.addEventListener('click', openModal);
        closeGuideBtn.addEventListener('click', closeModal);
        guideModal.addEventListener('click', (e) => e.target === guideModal && closeModal());

        registerEvent('mouse', 'mousedown', (e) => {
            drawCircle(e.clientX, e.clientY, colors.mouse, TYPE_SIZES.DOWN, 'mouse');
            logEvent(`MOUSE: mousedown at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        });
        
        registerEvent('mouse', 'mouseup', (e) => {
            drawCircle(e.clientX, e.clientY, colors.mouse, TYPE_SIZES.UP, 'mouse');
            logEvent(`MOUSE: mouseup at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        });
        
        registerEvent('mouse', 'mousemove', (e) => {
            if (e.buttons > 0) {
                drawCircle(e.clientX, e.clientY, colors.mouse, TYPE_SIZES.MOVE, 'mouse');
                logEvent(`MOUSE: mousemove at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
            }
        });
        
        registerEvent('mouse', 'mouseover', createLogHandler(
            () => 'MOUSE: mouseover (bubbles, fires on child elements)', true));
        
        registerEvent('mouse', 'mouseout', createLogHandler(
            () => 'MOUSE: mouseout (bubbles, fires on child elements)', true));
        
        registerEvent('mouse', 'mouseenter', createLogHandler(
            () => 'MOUSE: mouseenter (no bubble, only fires once on element)', true));
        
        registerEvent('mouse', 'mouseleave', createLogHandler(
            () => 'MOUSE: mouseleave (no bubble, only fires once on element)', true));
        
        registerEvent('mouse', 'wheel', (e) => {
            e.preventDefault();
            drawCircle(e.clientX, e.clientY, colors.mouse, TYPE_SIZES.WHEEL, 'mouse');
            const direction = e.deltaY > 0 ? 'down' : 'up';
            logEvent(`MOUSE: wheel ${direction} (deltaY: ${e.deltaY.toFixed(1)}) at ${formatCoords(e.clientX, e.clientY)}`);
        }, { passive: false });
        
        const handleTouch = (e, eventName, type) => {
            if (e.touches?.length > 0) {
                for (const touch of e.touches) {
                    drawCircle(touch.clientX, touch.clientY, colors.touch, TYPE_SIZES[type], 'touch');
                    logEvent(`TOUCH: ${eventName} at ${formatCoords(touch.clientX, touch.clientY)}`, 'redundant');
                }
            }
        };
        
        registerEvent('touch', 'touchstart', (e) => handleTouch(e, 'touchstart', 'DOWN'), { passive: true });
        registerEvent('touch', 'touchmove', (e) => handleTouch(e, 'touchmove', 'MOVE'), { passive: true });
        registerEvent('touch', 'touchend', (e) => {
            if (e.changedTouches?.length > 0) {
                for (const touch of e.changedTouches) {
                    drawCircle(touch.clientX, touch.clientY, colors.touch, TYPE_SIZES.UP, 'touch');
                    logEvent(`TOUCH: touchend at ${formatCoords(touch.clientX, touch.clientY)}`, 'redundant');
                }
            }
        }, { passive: true });
        
        const getPointerInfo = (e) => `(${e.pointerType}) at ${formatCoords(e.clientX, e.clientY)}`;
        
        registerEvent('pointer', 'pointerdown', (e) => {
            drawCircle(e.clientX, e.clientY, colors.pointer, TYPE_SIZES.DOWN, 'pointer');
            logEvent(`POINTER: pointerdown ${getPointerInfo(e)}`);
        });
        
        registerEvent('pointer', 'pointerup', (e) => {
            drawCircle(e.clientX, e.clientY, colors.pointer, TYPE_SIZES.UP, 'pointer');
            logEvent(`POINTER: pointerup ${getPointerInfo(e)}`);
        });
        
        registerEvent('pointer', 'pointermove', (e) => {
            drawCircle(e.clientX, e.clientY, colors.pointer, TYPE_SIZES.MOVE, 'pointer');
            logEvent(`POINTER: pointermove ${getPointerInfo(e)}`);
        });
        
        registerEvent('pointer', 'pointerover', createLogHandler(
            (e) => `POINTER: pointerover (${e.pointerType}) - bubbles, fires on child elements`));
        
        registerEvent('pointer', 'pointerout', createLogHandler(
            (e) => `POINTER: pointerout (${e.pointerType}) - bubbles, fires on child elements`));
        
        registerEvent('pointer', 'pointerenter', createLogHandler(
            (e) => `POINTER: pointerenter (${e.pointerType}) - no bubble, fires once on element`));
        
        registerEvent('pointer', 'pointerleave', createLogHandler(
            (e) => `POINTER: pointerleave (${e.pointerType}) - no bubble, fires once on element`));
        
        registerEvent('pointer', 'pointercancel', createLogHandler(
            (e) => `POINTER: pointercancel (${e.pointerType}) - pointer interaction cancelled by browser`));
        
        registerEvent('pointer', 'gotpointercapture', createLogHandler(
            (e) => `POINTER: gotpointercapture (${e.pointerType}) - pointer captured for exclusive events`));
        
        registerEvent('pointer', 'lostpointercapture', createLogHandler(
            (e) => `POINTER: lostpointercapture (${e.pointerType}) - pointer capture released`));
        
        registerEvent('click', 'click', (e) => {
            drawCircle(e.clientX, e.clientY, colors.click, TYPE_SIZES.CLICK, 'click');
            logEvent(`CLICK: click at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        });
        
        registerEvent('click', 'auxclick', (e) => {
            drawCircle(e.clientX, e.clientY, colors.click, TYPE_SIZES.AUX_CLICK, 'click');
            logEvent(`CLICK: auxclick (button ${e.button}: middle/side button) at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        });
        
        registerEvent('click', 'dblclick', (e) => {
            drawCircle(e.clientX, e.clientY, colors.click, TYPE_SIZES.DOUBLE_CLICK, 'click');
            logEvent(`CLICK: dblclick at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        });
        
        registerEvent('click', 'contextmenu', (e) => {
            e.preventDefault();
            drawCircle(e.clientX, e.clientY, colors.click, TYPE_SIZES.CONTEXT_MENU, 'click');
            logEvent(`CLICK: contextmenu (right-click) at ${formatCoords(e.clientX, e.clientY)}`, 'redundant');
        }, { passive: false });
        
        registerEvent('gesture', 'gesturestart', (e) => {
            e.preventDefault();
            const x = e.clientX ?? canvas.width / 2;
            const y = e.clientY ?? canvas.height / 2;
            drawCircle(x, y, colors.gesture, TYPE_SIZES.GESTURE, 'gesture');
            logEvent('GESTURE: gesturestart (Safari only)', 'redundant');
        }, { passive: false });
        
        registerEvent('gesture', 'gesturechange', (e) => {
            e.preventDefault();
            const scale = e.scale !== undefined ? e.scale.toFixed(1) : 'N/A';
            const rotation = e.rotation !== undefined ? e.rotation.toFixed(1) : 'N/A';
            logEvent(`GESTURE: gesturechange (Safari only) - scale: ${scale}, rotation: ${rotation}`, 'redundant');
        }, { passive: false });
        
        registerEvent('gesture', 'gestureend', (e) => {
            e.preventDefault();
            logEvent('GESTURE: gestureend (Safari only)', 'redundant');
        }, { passive: false });

        registerEvent('touch', 'touchcancel', createLogHandler(
            () => 'TOUCH: touchcancel - touch interrupted', true));

        const hasTouchScreen = window.matchMedia('(pointer: coarse)').matches;
        logEvent(`Device has touch screen: ${hasTouchScreen}`);

        const touchSupported = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        logEvent(`Touch events supported: ${touchSupported}`);
        logEvent(`Max touch points: ${navigator.maxTouchPoints || 0}`);
    </script>
</body>
</html>
